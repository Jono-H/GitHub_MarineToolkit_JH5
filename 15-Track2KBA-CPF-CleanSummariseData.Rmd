# Track2KBA - Central Place Foragers: Clean and summarise data for analysis

Analyses outlined in this chapter were performed in **`r sessionInfo()$R.version$version.string`**\

This chapter was last updated on **`r Sys.Date()`** 

<br>

<!--- This is an HTML comment in RMarkdown. You can use these comments to make notes that won't get read when running the code -->

<!--- If you don't understand what a RMarkdown document is. Stop here. Go learn. -->

<!--- Equally. You must understand the difference between Markdown vs. RMarkdown -->

<!--- Remember, outside of the R code chunks we are now coding in HTML syntax, not R syntax -->


## What this chapter covers:

-   Suggested steps to cleaning data from central place foraging animals (e.g. seabirds during the breeding period that regularly return to nests)

-   Cleaning central place foraging data and preparing for the purpose of analysing the data using the Track2KBA R package

-   Deriving basic summary statistics about tracks of central place foraging animals

<br>

## Outputs and assumptions of data within this chapter:

-   Two key outputs are derived:

    -   A data frame of tracking data which has had tracks split into individual trips. The trip data has been cleaned via a speed filter and linear interpolation. Only complete trips are kept for further analyses.
    
    -   A summary data frame of basic statistics about the tracking data
    
-   A key assumption:

    -   The use of complete trips only does not bias final outcomes. 


<br>

## Where you can get example data for the chapter:

This tutorial uses example data from a project led by the BirdLife International partner in Croatia: BIOM

-   The citation for this data is: **TBC**

-   The example data can be downloaded from: **See chapter about merging tracking data**

-   A description of the example data is given in a separate chapter

<!--- In the code chunk below, we specify include = F, so that we will run the chunk but not include the chunk in the final document. We set a global argument in the code chunk of echo = T, so that in later code chunks, the code will be displayed in the RMarkdown document -->

```{r track2kba-prep-setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
## we also specify in the options here to set the overall working directory
## back to the root directory of the R Project we are working in. We do this
## because by default , the working directory for R code chunks is the directory 
## that contains the Rmd document. We don't want this option given our file
## set up prefers the option of having the working directory specified as that
## where the R Project is. By specifying double dots (or more), this is like saying
## go back one directory or more, as required.
knitr::opts_knit$set(root.dir = ".")
```

<br>


## Load packages

**Load required R packages for use with codes in this chapter:**

If the package(s) fails to load, you will need to install the relevant package(s).

```{r track2kba-prep-load-packages, include = TRUE}

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Load libraries --------------------------------------------------------------
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

"Had to install R version: R version 4.2.2 (2022-10-31 ucrt) for aniMotum"
"Animotum and CRAWL style interpolation in Appendix - not default comparison"
## Options to install aniMotum package for animal track interpolation
## aniMotum: https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.14060
#install.packages('aniMotum', repos = c('https://ianjonsen.r-universe.dev', 'https://cloud.r-project.org'))
# may need to install aniMotum after downloading using: devtools::install_local(package.zip)
#install.packages('TMB', type = 'source')
#library("aniMotum")


## sf package for spatial data analyses (i.e. vector files such as points, lines, polygons)
library(sf)
## Tidyverse for data manipulation
library(tidyverse)
## ggplot2 for plotting opionts
library(ggplot2)
## rnaturalearth package for basemaps in R
library(rnaturalearth)
## leaflet package for interactive maps in R
#install.packages("leaflet")
library(leaflet)
##
library(purrr)
library(furrr)
#install.packages("track2KBA")
library(track2KBA)
## for date time
library(lubridate)
## for stats
library(stats)
## speed filter
library(trip)
## linear interpolation
library(adehabitatLT)

```

<br>

## Define object names for chapter

Typically, if your data follows the same format as the examples in the chapter (and previous chapters), then below should be the only thing(s) you need to change.

```{r track2kba-prep-objects}

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Specify projections / store needed CRS definitions as variables ----
## SEE: https://epsg.io/
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## world - unprojected coordinates
# wgs84 <- st_crs("EPSG:4326")


## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Source a relevant basemap (download / or load your own)
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Source a world map from the rnaturalearth R package
## see details of function to change the type of map you get
## If you can't download this map - you may need to load a separate shapefile
## depicting a suitable basemap
# worldmap <- rnaturalearth::ne_download(scale = "large",
#                                        type = "countries",
#                                        category = "cultural",
#                                        destdir = tempdir(),
#                                        load = TRUE,
#                                        returnclass = "sf")

```

<br>

## Load file (or file created from previous chapter)

```{r track2kba-prep-load}

## Read the csv file of merged tracking data that follows the output / download format
## of the Seabird Tracking Database
df_stdb_output <- read.csv("./data-testing/tracking-data/Puffinus-yelkouan-Z-tracking-STDB-output.csv")

```

> NOTE: The example data used here is in the format of data downloaded from the Seabird Tracking Database. Your own data might not follow this format. However, many of the steps outlined below should be readily adaptable to your data so long as you modify column names or respective inputs accordingly.

<br>

## dataGroup: prepare relevant grouping of data for analyses

[See previous chapter which introduces the dataGroup concept - ensure your data is group accordingly when deriving a final output using the Track2KBA R package]

```{r track2kba-prep-review}

## Reminder on what the data looks like so far
head(data.frame(df_stdb_output),2)

## Review the main columns of data separately. This helps check for errors associated 
## with data entry. E.g. perhaps you typed chick-rearing and CHICK-rearing. Because
## of the difference in lower-case vs. upper-case text, you might accidentally consider
## these as separate components of your dataset.
## the table function is useful to check the unique number of entries per unique input
table(df_stdb_output$scientific_name)
table(df_stdb_output$site_name)
table(df_stdb_output$colony_name)
table(df_stdb_output$breed_status)
table(df_stdb_output$breed_stage)
table(df_stdb_output$age)
table(df_stdb_output$sex)
```


```{r track2kba-prep-dgroup-sum}
## Summarise the data by species, site_name, colony_name, year, breed_status (if you have this), breed_stage, age, sex.
## First we add a new year column by splitting the date column so we can get information about years
df_overview <- df_stdb_output %>% mutate(year = year(date_gmt)) %>% 
  ## then we group the data by relevant columns
  group_by(scientific_name, 
           site_name, 
           colony_name, 
           year,
           #breed_status, # if you downloaded data from the STDB, you should have this info.
           breed_stage,
           age, 
           sex,
           device) %>% 
  ## then we continue to summarise by the distinct number of entries per group
  summarise(n_birds = n_distinct(bird_id),
            n_tracks = n_distinct(track_id))

## review the summary output
df_overview

```

<br>

### dataGroup: Defining the dataGroup for the tutorial

From the summary above, we can see that we have data for:

-   One species

-   One colony

-   adult birds only

-   tracks from the chick-rearing period only 

-   all tracked with GPS devices

-   tracked for two seasons

[From preliminary data exploration, we decided to pool tracks from the two years given birds were utilising the same areas]

[Insert Martin's new paper about sample size / years of tracking data]

**dataGroup for the tutorial is therefore defined as:** Adult Puffinus yelkouan, tracked from colony Z, during the chick-rearing period.

[See the separate chapter about defining your dataGroup for analyses for further details]

<br>

### dataGroup: extracting data for the analyses

>[Note, if you had already merged data for multiple species, colonies, or breeding stages, and you were using this data as your input file, here is where you would need to separate your data into unique dataGroups for further analyses]


<br>

## dataGroup inspection: visual review

[NOTE: Previous chapters detailing options for data exploration and suggestions for additional cleaning steps if required]

Here, we visually inspect the overall data to double check it generally looks correct.

A reminder on initial pre-filtering which may need to happen:

What should you look for when visualising the raw data?
 * Are your locations in realistic places?
 * Have you perhaps mixed up the latitude and longitude columns?
 * Does your data cross the international date line? Do you know how to deal with this?
 * Will you need to remove sections of the data that do not represent a time when the animal was tagged? (e.g. perhaps you set the device to start recording locations before deploying on the animal. So the tag might have recorded while you were travelling to the deployment location. Therefore, removing these sections of the track will facilitate your overall analysis.)


```{r track2kba-prep-ind-review-dataGroup, include = TRUE}

## quick plot of all data for a quick overview
dataGroup.plot <- st_as_sf(df_stdb_output, coords = c("longitude", "latitude"), crs=4326) # 4326 = geographic WGS84
plot(st_geometry(dataGroup.plot), 
     cex = 0.5, 
     pch = 1)

## number of datapoints
nrow(df_stdb_output)

## interactive plot
leaflet() %>% ## start leaflet plot
  addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") %>% 
  ## plot the points. Note: leaflet automatically finds lon / lat colonies
  ## Colour accordingly.
  addCircleMarkers(data = df_stdb_output,
                   radius = 3,
                   fillColor = "cyan",
                   fillOpacity = 0.5, stroke = F) 


```



<br>

## Arrange data and remove duplicate entries

Once you have formatted your data into a standardised format and ensured that parts of your data is inputted correctly, it is also worth ensuring your data is ordered (arranged) correctly chronologically. An artifact of manipulating spatial data is that sometimes the data can become un-ordered with respect to time, or, given the way various devices interact with satellites, you can also end up with duplicated entries according to timestamps.

This can be a first problem, causing your track to represent unrealistic movement patterns of the animal.

We need to ensure our data is ordered correctly and also remove any duplicate timestamps.

```{r track2kba-prep-remove-duplicates, include=TRUE}

## review your OVERALL data again
head(data.frame(df_stdb_output),2)

(str(df_stdb_output))

## merge the date and time columns
df_stdb_output$dttm <- with(df_stdb_output, ymd(date_gmt) + hms(time_gmt))

## first check how many duplicate entries you may have. If there are many, it
## is worth exploring your data further to understand why.
n_duplicates <- df_stdb_output %>% 
  group_by(bird_id, track_id) %>% 
  arrange(dttm) %>% 
  dplyr::filter(duplicated(dttm) == T)

## review how many duplicate entries you may have. Print the message:
print(paste("you have ",nrow(n_duplicates), " duplicate records in a dataset of ",
            nrow(df_stdb_output), " records.", sep =""))
            
## remove duplicates entries if no further exploration is deemed necessary
df_stdb_output <- df_stdb_output %>% 
  ## first group data by individual animals and unique track_ids
  group_by(bird_id, track_id) %>% 
  ## then arrange by timestamp
  arrange(dttm) %>% 
  ## then if a timestamp is duplicated (TRUE), then don't select this data entry.
  ## only select entries where timestamps are not duplicated (i.e. FALSE)
  dplyr::filter(duplicated(dttm) == F)

```

<br>

## Speed filter GPS data: remove erroneous location points

It's often the case that some location points will be in artificial places (i.e. the wrong places). This can happen for many reasons.

To automatically remove some of these artifical locaiton points prior to analyses, one can apply a speed filter.

Here we use the McConnel Speed Filter [insert speed filter reference]

```{r track2kba-prep-speed-filter}

## review
head(data.frame(df_stdb_output),2)

## reminder on total number of animals tracked
length(unique(df_stdb_output$bird_id))

## Define maximum speed in km/h (kilometers per hour)
speed.filter.threshold <- 100 ## Important number to change depending on whether you have flying or non-flying seabirds

## create blank data frame to capture filtered tracks and summary data
tracks_speed <- data.frame()
tracks_speed_summary <- data.frame()

## 
for(i in 1:length(unique(df_stdb_output$bird_id))){
  temp <- df_stdb_output %>% dplyr::filter(bird_id == unique(df_stdb_output$bird_id)[i])
  
  ## remove any erroneous locations due to speed use the McConnel Speed Filter 
  ##from the trip package
  trip_obj <- temp %>% 
    group_by(bird_id) %>% 
    dplyr::select(x = latitude, 
                  y = longitude, 
                  dttm, 
                  everything()) %>% 
    trip()
  
  ## McConnel Speedilter -----
  ## apply speedfilter and create data frame
  trip_obj$Filter <- speedfilter(trip_obj, max.speed = speed.filter.threshold)  # speed in km/h
  trip_obj <- data.frame(trip_obj)
  #head(trip_obj,2)
  #dim(trip_obj)
  
  ## Keep only filtered coordinates - after checking dimensions of other outputs again
  trip_obj <- subset(trip_obj,trip_obj$Filter==TRUE)
  
  ## bind back onto dataframe
  tracks_speed <- rbind(tracks_speed, trip_obj)
  
  ## Populate summary data
  temp_summary <- data.frame(bird_id = temp$bird_id[1],
                             n_points_PreFilter = nrow(temp),
                             n_points_PostFilter = nrow(trip_obj),
                             points_removed = ifelse(nrow(temp)-nrow(trip_obj) > 0, "Yes", "No"))
  
  ## bind on summary information
  tracks_speed_summary <- rbind(tracks_speed_summary, temp_summary)
  
  ## remove temporary items before next loop iteration
  rm(temp,trip_obj, temp_summary)
  
  ## Print loop progress
  print(paste("Track ", i, " of ", length(unique(df_stdb_output$bird_id)), " processed"))

}

## review overall
head(tracks_speed,2)

## review summary
tracks_speed_summary

## update column names in speed filtered tracks
tracks_speed <- tracks_speed %>% 
  mutate(latitude = x,
         longitude = y)

```

<br>

## Speed filter PTT data: remove erroneous location points

[See Appendix for example code showcasing how to speed filter PTT data]

<br>

## Speed filter data review: plotting

Plot the track of an animal with speed filtered data versus non-filterd data.

[Consider - is using leaflet the best way to do this? Should we use other defaults]

[leaflet requires an internet connection...]


```{r track2kba-prep-speedfilter-plots}

## Get the ID of the first example track of animal with speed filtered data
example_animal <- tracks_speed_summary %>% 
  dplyr::filter(points_removed == "Yes") %>% 
  slice(1) %>% 
  dplyr::select(bird_id)

## Get the original data
non.speed.filtered <- df_stdb_output %>% dplyr::filter(bird_id == example_animal$bird_id)

## Get the speed filtered ata
speed.filtered <- tracks_speed %>% dplyr::filter(bird_id == example_animal$bird_id)

## plot original vs speedfiltered data

## interactive plot
leaflet() %>% ## start leaflet plot
  addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") %>% 
  ## plot the points. Note: leaflet automatically finds lon / lat colonies
  ## Colour accordingly.
  ## ORIGINAL TRACK
  addCircleMarkers(data = non.speed.filtered,
                   radius = 3,
                   fillColor = "red",
                   fillOpacity = 1, 
                   stroke = F) %>% 
  ## Plot lines between original track points
  addPolylines(lng = non.speed.filtered$longitude,
               lat = non.speed.filtered$latitude, weight = 1,
               color = "red") %>% 
  ## SPEED FILTERED TRACK
  addCircleMarkers(data = speed.filtered,
                   #label = bird_track$nlocs, 
                   radius = 3,
                   fillColor = "cyan",
                   fillOpacity = 1, 
                   stroke = F) %>% 
## plot lines between speed filtered points
  addPolylines(lng = speed.filtered$longitude,
               lat = speed.filtered$latitude, weight = 1,
               color = "cyan") 

```

## Data cleaning for CPF: n_locs, sampling interval, interpolation

So far, the following data cleaning steps have been applied:

-   General review of spatial data

-   Removing - if necessary - sections of tracks when animals were not tracked but devices were recording information [example code / procedures not yet provided]

-   Arranging data chronologically and removing duplicate entries

-   Speed filter for clearly erroneous location points


<br>

Further cleaning of data will typically be necessary for many analyses. Steps may include:

-   Removing data with too few location points

-   Reviewing the sampling frequency of data (i.e. what frequncy you set your devices to record at versus what they actually recorded at)

-   Interpolating data to generate tracking information that approximates an even sampling interval

When to clean data with respect to the steps above may depend on the type of animal you tracked.

<br>

### Data cleaning for CPF seabirds: tracks vs. trips

If you have been tracking central place foraging animals, it's likely that you will have many trips recorded from an individual that was tracked. 

[Insert example image to showcase what we mean]

**Defining trips:** For the purpose of analysing central place foraging data with track2kba, we consider a unique trip to be the period of time from when an animal departs its colony (or particular nest), to the moment it returns to the colony (or particular nest).

Therefore, if we have tracking information from individuals over sufficient time period, it's likely you will have recorded information about multiple trips. 

We need to split the information into unique trips.

Functions in the track2kba R package can help us do this.


### Data cleaning for CPF seabirds: Nesting habitat considerations

[Consider suitable name for this section].

For CPF species that nest in burrows, forests, or other locations where satellite signals may become interrupted for extend periods of time, it can be worth first splitting the overall tracking information into individual trips before filtering or cleaning data further according to number of locations (n_locs) or recorded sampling frequency.

<br>

> EXAMPLE DATA CONSIDERATIONS (Burrow nesting species): Puffinus yelkouan is a burrow nesting species. Therefore, we expect to have long gaps in the tracking information while the birds are sitting on nests (because satellite signals with the tracking device will be interuppted). For this reason, we will first split the tracking information into individual trips, and then apply further filters.

<br>

> [If you have tracking information from a species where satellite signal is unlikely to be interuppted from permanent features such as burrows or trees, it may be suitable to filter your data further before splitting tracks into individual trips because data is unlikely to be as biased by the presence of permanent physical features.]


<br>

## track2KBA: format data for use

<br>

### track2KBA::formatFields()

This function will help format your data to align with that required of track2KBA.

In other words: for the track2KBA functions to work, your data needs to have certain columns named in the appropriate way. This function will help with that.

> We apply the formatting to the most recently filtered data.

```{r track2kba-prep-formatFields, include = TRUE}

## Format the key data fields to the standard used in track2KBA
dataGroup <- formatFields(
  ## your input data.frame or tibble
  dataGroup = tracks_speed, 
  ## ID of the animal you tracked
  fieldID   = "bird_id", 
  ## date in GMT
  fieldDate = "date_gmt", 
  ## time in GMT
  fieldTime = "time_gmt",
  ## longitude of device
  fieldLon  = "longitude", 
  ## latitude of device
  fieldLat  = "latitude"
)

## Check output. Output is a data.frame
head(dataGroup,2)
str(dataGroup)


```

<br>

## track2KBA: Split tracks into trips

Splitting tracks into trips can be achieved with the `tripSplit()` function within track2kba.

Suitable parameters must first be applied / considered.

**What does tripSplit() do:** [Consider text from the track2kba manuscript]

**When not to apply tripSplit():** If your data does not relate to a central place forager (CPF), OR
a time when an animal may be exhibiting central place foraging behaviours, then applying tripSplit will not be appropriate.

**How tripSplit() helps:** This step is often very useful to help automate the removal of location points
on land, or near the vicinty of a colony. We don't want these extra points to bias
our interpretation of the data.

**General considerations when applying tripSplit():** The user must define ecologically sensible parameters to help automate the tripSplitting process.


<br>

### Define colony of origin

First define a colony of origin for each individual animal tracked.

This can be achieved in several ways.

Ultimately, you must take scale into account.

[Further details to be provided]

```{r track2kba-prep-colony}

## ~~~ Option 1: Manually specify a unique colony location for all birds
# colony <- data.frame(Longitude = 16.875879, Latitude  = 42.774843)


## ~~~ Option 2: Same unique colony for all birds - extracted from data
## Define the colony position based on the first longitude and latitude coordinates 
## which SHOULD originate from the breeding colony if all birds tracked appropriately 
## from the same colony. Unlikely to be possible for burrow nesting species.
# colony <- dataGroup %>% 
#   summarise(
#     Longitude = first(Longitude), 
#     Latitude  = first(Latitude))

## ~~~ Option 3: Specify unique colony or unique nest per bird
## IF colony / nest locations vary more widely, then create unique dataframe
## for each bird / animal tracked. Specify a unique nesting location for each
## animal based on the first coordinate of the track.
# colony_nest <- dataGroup %>% 
#   group_by(ID) %>% 
#   summarise(
#     ID = first(ID),
#     Longitude = first(Longitude), 
#     Latitude  = first(Latitude)
#   ) %>% 
#   data.frame()

## Option 4: Define colony of origin based on associated metadata
## Note - this could also be a separate metadata table so long as the IDs can match up.
colony_nest <- dataGroup %>%
  group_by(ID) %>%
  summarise(
    ID = first(ID),
    Longitude = first(lon_colony),
    Latitude  = first(lat_colony)
  ) %>%
  data.frame()

## review
colony_nest


```

<br>

### Colony of origin review

It can be worth plotting the colony of origin data to ensure colony location has been correctly assigned

```{r track2kba-prep-colony-review}

## interactive plot - review where the individual colony location records
## were deemed to be.
leaflet() %>% ## start leaflet plot
  addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") %>% 
  ## plot the points. Note: leaflet automatically finds lon / lat colonies
  ## Colour accordingly.
  addCircleMarkers(data = data.frame(dataGroup),
                   radius = 3,
                   fillColor = "cyan",
                   fillOpacity = 0.5, stroke = F) %>% 
  ## plot the colony locations from birds
  addCircleMarkers(data = data.frame(colony_nest),
                   radius = 5,
                   fillColor = "red",
                   fillOpacity = 0.5, stroke = F) 

```

In the example above, we can see that the colony location for all nests is represented by a single point. We know the island is small compared to the scale at which these birds and we deem the single colony location to sufficiently represent the nesting location all birds.


<br>

### Apply `tripSplit()`

```{r track2kba-prep-tripSplit, include = TRUE}

## First define your key parameters outside of the function. Useful for using them later again if needed.

inner.buff.distance = 3 # km - defines distance an animal must travel to count as trip started
return.buff.distance = 10 # km - defines distance an animal must be from the colony to have returned and thus completed a trip
duration.time = 1 # hours - defines time an animal must have traveled away from the colony to count as a trip. helps remove glitches in data or very short trips that were likely not foraging trips.

## Input is a 'data.frame' of tracking data and the central-place location(s). 
## Output is a 'SpatialPointsDataFrame'.
trips <- tripSplit(
  dataGroup  = dataGroup,
  colony     = colony_nest, # define source location.
  innerBuff  = inner.buff.distance,      
  returnBuff = return.buff.distance,     
  duration   = duration.time,     
  nests = T,           # specify nests = T if using unique colony locations per animal,
  gapLimit = NULL, # The period of time between points (in days) to be considered too large to be a contiguous tracking event
  rmNonTrip  = F    # If true, points not associated with a trip will be removed / if false, points not associated with a trip will be kept
)

## Review data after tripSplit()
head(trips,2)
str(trips)
table(trips$Returns)

```

["NOTE: the messages that may relate to 'track .... does not return to the colony',
is actually referring to the individual trips from each animal tracked. The code
for track2KBA package needs to be revised to display an '_' between the track ID 
and the individual trip ID. So instead of reading something like 693041, it should
read 69304_1, to better refer to trip 1 of track 69304."]


### Review of tripSplit() output

In the example above, we specified `rmNonTrip = F` so as not remove any points not deemed as associated with a trip. I.e. the points typically lying within the `innerBuff` distance and for those where the animal traveled for less than `duration` specified,

Let's review the general points we are not considering as part of trips.

Split the locations into points to keep and those that will be removed (i.e. the points not associated with a trip) for visual plot of the tracks using leaflet package in R.

Note: when specifying `rmNonTrip = F`, location points are assigned under the column **Return** as either: 

-   Yes (part of trip that animal returns to colony), 

-   No (part of a trip where animal does not return to colony),

-   or Blank (location point that would be removed)


```{r track2kba-prep-points-to-keep}

## Split the points
points_to_keep <- data.frame(trips) %>% 
  dplyr::filter(Returns %in% c("Yes", "No"))
##
points_to_remove <- data.frame(trips) %>% 
  dplyr::filter(!Returns %in% c("Yes", "No"))

map <- leaflet() %>% ## start leaflet plot
  addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") %>% 
  ## plot the points. Note: leaflet automatically finds lon / lat colonies
  ## Colour accordingly.
  addCircleMarkers(data = points_to_keep,
                   radius = 3,
                   fillColor = "cyan",
                   fillOpacity = 0.5, stroke = F) %>% 
  ##
  addCircleMarkers(data = points_to_remove,
                   radius = 3,
                   fillColor = "red",
                   fillOpacity = 0.5, stroke = F)
  
map

```

### Understanding what is happening in tripSplit() further

Essentially, we are using a function that helps us bulk clean tracking data. The goal is to assign individual trips to multiple animals that have been tracked, and doing this in an automated way.

> Go back and change `innerBuff` and `duration` parameters in particular, and recreate the plot above showing the points not associated with a trip. See how changing the arguments impacts the likely data that will be removed for the analysis. You only want to remove (i.e. "clean up") the points that are most likely not associated with a trip.


### Review the individual trips for each tracked animal after applying tripSplit()

A simple way to do this is with the `mapTrips` function.

The plots show an overview of individual trips per bird. Only data for the first 25 birds is shown.

```{r track2kba-prep-mapTrips, include = TRUE}

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## track2KBA::mapTrips() ----
## view data after splitting into trips ----
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## plot quick overview of trips recorded for individual birds (i.e. the plots show
## an overview of individual trips per bird). Only data for the first 25 birds is
## shown
mapTrips(trips = trips, colony = colony_nest)

## If you want to map the trips from the next 25 animals tracked, use the IDs argument
mapTrips(trips = trips, IDs = 26:50, colony = colony_nest)

```

### Plot the individual trips for each tracked animal after applying tripSplit()

If, after reviewing the simplified plots of individual trips for each tracked animal using the `mapTrip()` function you are not satisfied, then you should explore the relative data further.

[One way of exploring the trips outputted for individually tracked animals would be to rapidly review summary plots for each trip, showing start, journey, and end points, where the point locations are also joined together with a line. Should consider inlcuding this plotting option. Perhaps also with option of specifying a vector of relative individuals.]


<br>

## track2kba: What trip data to use (complete or incomplete trips)

[Keeping points associated with complete trips only is the approach considered in the `track2KBA` online tutorial. But you may want to explore which trips you are keeping or not.]

[users may wish to consider if too many individual trips have been removed.
i.e. if you tracked 30 birds and you estimated to have approximately 3 trips 
recorded per bird, then you would have a total of 90 trips. But it's likely that
on some trips, that not the entire trip was recorded (for multiple reasons).
Therefore, you might expect to rather have about 83 trips recorded across all
birds because for 7 trips data might not have indicated birds returned to the colony.
If you had a very high proportion of trips that did not return to the colony, then
it's likely that you have defined the parameters incorrectly for tripSplit() and you
should reconsider better ecologically based estimates for these parameters. There
is of course the chance that there are other issues with your data which would warrant
more detailed exploration.]

```{r track2kba-prep-keep-complete-trips, include = TRUE}

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Keep points associated with individual trips ----
## Filter the data to only keep the points associated with individual trips that
## were recognised as complete trips.
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Let's first check how many trips we record as Yes vs. No before filtering
head(trips,2)

## summary of trips associated with Return or not
totalTripsAll <- data.frame(trips) %>% group_by(tripID, Returns) %>% 
  summarise(count = n()) %>% 
  data.frame(.)
## view summary result
table(totalTripsAll$Returns)

## NOW, Filter to only include trips that return
trips.return.yes <- subset(trips, trips$Returns == "Yes" )
totalTripsYes <- data.frame(trips.return.yes) %>% group_by(tripID, Returns) %>% 
  summarise(count = n()) %>% 
  data.frame(.)
## view summary result
table(totalTripsYes$Returns)

## Filter for trips that do not reutrn
trips.return.no <- subset(trips, trips$Returns == "No" )
totalTripsNo <- data.frame(trips.return.no) %>% group_by(tripID, Returns) %>% 
  summarise(count = n()) %>% 
  data.frame(.)
## view summary result
table(totalTripsNo$Returns)

## CONSIDER and compare: total trips that returned vs. did not:
table(totalTripsYes$Returns)
table(totalTripsNo$Returns)

```


### track2KBA: Choice of complete trips only

If you want to explore further the trips that were not considered to have returned, then use the object above, `trips.return.no`, to investigate the individual trips further. E.g. through individual plotting.

For our example, we have 325 complete trips and 19 incomplete trips; a very small proportion of incomplete trips. We, therefore, deem our choice of input parameters as ecologically sensible for the tripSplit() function and use only the complete trips for further analyses.

```{r track2kba-prep-keep-complete-trips-choose, include = TRUE}

## select, rename, and use only the complete trips for further analyses
trips <- trips.return.yes

```

## track2KBA: Use only at-sea sections of trips

**Key considerations related to identifying IBAs / KBAs:** when identifying an IBA or KBA for seabirds using the track2KBA protocol, you effectively need information about the source population (typically the colony) and distribution data (tracking data). This means that not only can you identify a pelagic site from tracking data, but you can also consider an IBA/KBA for the colony itself and a possible at-sea buffer (seaward extension) around the colony.

<br>

Because you should typically consider identifying the seaward extension around the colony in addition to any potential pelagic / offshore sites supported by the tracking data, you can remove location points from the data within a suitable buffer distance (typically the inner buffer distance used in the `tripSplit()` function.

```{r track2kba-prep-5locs}

## remove locations near the vicinity of the colony - distance is in m (unlike innerBuff where distance was in km)
head(trips,2)
trips <- trips[trips$ColDist > inner.buff.distance*1000, ]

## Plot to review
## interactive plot - including colony location(s)
leaflet() %>% ## start leaflet plot
  addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") %>% 
  ## plot the points. Note: leaflet automatically finds lon / lat colonies
  ## Colour accordingly.
  addCircleMarkers(data = data.frame(trips),
                   radius = 3,
                   fillColor = "cyan",
                   fillOpacity = 0.5, stroke = F) %>% 
  ## plot the colony locations from birds
  addCircleMarkers(data = data.frame(colony_nest),
                   radius = 5,
                   fillColor = "red",
                   fillOpacity = 0.5, stroke = F) 

```

Note: in the plot above, you may need to zoom into the colony of origin to ensure points have been removed accordingly.

<br>

## track2KBA: Number of locations filter

It is worth considering the total number of location points contributing to each trip after splitting tracks from animals. Even if you are not splitting tracks into trips, using location data from animals where you have very few data points may bias your results.

> Recommendation for the track2kba analytical approach is to use data with at least >5 location points 
 
```{r track2kba-prep-5locs-2}

## create data frame and find IDs of trips with >5 locations; as required for track2KBA analysis
trips_to_keep <- data.frame(trips) %>% 
  group_by(tripID) %>% 
  summarise(triplocs = n()) %>% 
  dplyr::filter(triplocs > 5)
  
## select the relevant tripIDs only and create new object
trips_df <- data.frame(trips) %>% 
  dplyr::filter(tripID %in% trips_to_keep$tripID)

## Compare how many trips you removed
## Before
length(unique(trips$tripID))
## After
length(unique(trips_df$tripID))

```
 
[explore / consider: impact of pre-filtering steps on individual trips being removed with <5 points] 

<br>

## track2KBA: tripSummary()

This will give us a guide to summary statistics about the tracking data from central place foraging animals.

```{r track2kba-prep-tripsummary}

## tripSummary() ----
sumTrips <- tripSummary(trips = trips_df, colony = colony_nest, nests = T)

## Check you only have complete trips here (if that is what you are aiming for)
table(sumTrips$complete)

## filter for only complete trips if needed
#sumTrips  <- sumTrips  %>% dplyr::filter(complete= "complete trip")

## view output
head(sumTrips ,10)
## view unique individual ID
unique(sumTrips$ID)
## number of individuals with tracking data
length(unique(sumTrips$ID))
## number of unique trips from all individuals
length(unique(sumTrips$tripID))

```

<br>

### Trip summary data review

NOTE: These metrics are just summaries of summary data. Additional methods may help you summarise your data in greater detail.

[Consider further steps for providing summary of tracking data]

```{r track2kba-prep-tripsummary-review}

## Visual summary of data ----
## all data
all_tracks_sum <- sumTrips  %>% mutate(group = "all_tracks") %>% 
  group_by(group) %>% 
  summarise(n_trips = n(),
            avg_triptime_h = round(mean(duration),2), 
            med_triptime_h = round(median(duration),2), 
            min_triptime_h = round(min(duration),2),
            max_triptime_h = round(max(duration),2),
            avg_totdist_km = round(mean(total_dist),2), 
            med_totdist_km = round(median(total_dist),2), 
            min_totdist_km = round(min(total_dist),2),
            max_totdist_km = round(max(total_dist),2),
            avg_maxdist_km = round(mean(max_dist),2), 
            med_maxdist_km = round(median(max_dist),2), 
            min_maxdist_km = round(min(max_dist),2),
            max_maxdist_km = round(max(max_dist),2)) %>% data.frame()
## review all data summary
all_tracks_sum

## by individual
bird_sum <- 
  sumTrips  %>% 
  group_by(ID) %>% 
  summarise(n_trips = n(),
            avg_triptime_h = round(mean(duration),2), 
            med_triptime_h = round(median(duration),2), 
            min_triptime_h = round(min(duration),2),
            max_triptime_h = round(max(duration),2),
            avg_totdist_km = round(mean(total_dist),2), 
            med_totdist_km = round(median(total_dist),2), 
            min_totdist_km = round(min(total_dist),2),
            max_totdist_km = round(max(total_dist),2),
            avg_maxdist_km = round(mean(max_dist),2), 
            med_maxdist_km = round(median(max_dist),2), 
            min_maxdist_km = round(min(max_dist),2),
            max_maxdist_km = round(max(max_dist),2)) %>% data.frame()

bird_sum

## save the data as an excel sheet
#write.xlsx(bird_sum, file = "./Data/track2KBA_output/TrackingData_Summary.xlsx", 
#           sheetName = "Sheet1", 
#           col.names = TRUE, row.names = T, append = FALSE)


## histograms - foraging trip duration
p1 <- ggplot(sumTrips , aes(duration)) +
  geom_histogram(colour = "darkgrey", fill = "cyan")+
  theme(
    axis.text=element_text(size=14, color="black"),
    axis.title=element_text(size=16),
    panel.background=element_rect(fill="white", colour="black")) +
  ylab("n tracks") + xlab("Duration (hours)")

p1


## total distance traveled from the colony
p2 <- ggplot(sumTrips , aes(total_dist)) +
  geom_histogram(colour = "darkgrey", fill = "cyan")+
  theme(
    axis.text=element_text(size=14, color="black"),
    axis.title=element_text(size=16),
    panel.background=element_rect(fill="white", colour="black")) +
  ylab("n tracks") + xlab("Total dist. travelled (km)")

p2


## maximum distance traveled from the colony
p3 <- ggplot(sumTrips , aes(max_dist)) +
  geom_histogram(colour = "darkgrey", fill = "cyan")+
  theme(
    axis.text=element_text(size=14, color="black"),
    axis.title=element_text(size=16),
    panel.background=element_rect(fill="white", colour="black")) +
  ylab("n tracks") + xlab("Max dist. from colony (km)")

p3


## save the plots
#ggsave(filename = paste("./Plots/HistSummary_Duration.png",sep=""), 
#       p1, 
#       dpi = 300, units = "mm", width = 180,height = 130)


#ggsave(filename = paste("./Plots/HistSummary_TotDist.png",sep=""), 
#       p2, 
#       dpi = 300, units = "mm", width = 180,height = 130)


#ggsave(filename = paste("./Plots/HistSummary_MaxDist.png",sep=""),
#       p3, 
#       dpi = 300, units = "mm", width = 180,height = 130)



```

 

## track2KBA: Sampling interval assessment

To implement track2KBA fully, you need data approximating an even sampling interval
i.e. location points must be regularly spaced in time.
Determine how "gappy" the tracking data is (time intervals between location data)
This is an important step for almost all tracking data analyses.
If your data is not filtered / cleaned correctly, results may be spurious.

```{r track2kba-prep-sampling-interval, include = TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Check sampling interval ----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## data for summarising
head(data.frame(trips_df),2)
## double type of trips points are associated with
table(trips_df$Returns)

## Determine difference between consecutive timestamps 
## (NB: consecutive order of timestamps is critical here!)
## Doing this by tripID, not individual ID - change the group_by argument if needed
timeDiff <- trips_df %>% 
  data.frame() %>% 
  group_by(tripID) %>% 
  arrange(DateTime) %>% 
  mutate(delta_secs = as.numeric(difftime(DateTime, lag(DateTime, default = first(DateTime)), units = "secs"))) %>% 
  slice(2:n()) 

head(data.frame(timeDiff),2)
hist(timeDiff$delta_secs)

## plot histogram of timediff between all points
"This plot will take time depending on size of dataset!"
p4 <- ggplot(timeDiff , aes(delta_secs)) +
  geom_histogram(colour = "darkgrey", fill = "cyan", binwidth = 200)+
  theme(
    axis.text=element_text(size=14, color="black"),
    axis.title=element_text(size=16),
    panel.background=element_rect(fill="white", colour="black")) +
  ylab("n locations") + xlab("Time diff between locations (secs)")
p4

## Summarise results by tripID
SummaryTimeDiff <- timeDiff %>% 
  group_by(tripID) %>% 
  summarise(mean_timegap_secs = mean(delta_secs),
            median_timegap_secs = median(delta_secs),
            min_timegap_secs = min(delta_secs),
            max_timegap_secs = max(delta_secs)) %>%
  ## time in days
  mutate(max_timegap_days =  max_timegap_secs / 86400) %>% 
  mutate(max_timegap_days = round(max_timegap_days,2)) %>% 
  data.frame()

## View results
SummaryTimeDiff
head(SummaryTimeDiff)


```

### Sampling interval review

> Consider whether the sampling interval of your tracking data is appropriate
  for formally running the track2KBA functions. Remember, the time differences
  between each of your location points should be equal (or close enough to equal) 
  across all location points and individuals tracked. If the time difference
  between location points is not equal, the outputs you generate from track2KBA
  will not be valid because the underlying kernel density analysis implemented
  within the track2KBA functions will be invalid 
  (because you need points evenly spaced in time for this analysis to be valid).

Therefore, review the summary of your recorded sampling interval data:

```{r track2kba-prep-sampling-interval-review, include = TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Review sampling interval ----
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## Average sampling interval of all data
## median of median time gaps in minutes
median(SummaryTimeDiff$median_timegap_secs)/60

## Sort data by maximum time gap first - then view.
## Consider if you have any outlier trips with massively different time gaps.
SummaryTimeDiff %>% arrange(-max_timegap_secs) %>% head(10)

## simple histogram 
hist(SummaryTimeDiff$max_timegap_days)

```

If you have trips where the maximum time gap in seconds (`max_timegap_secs`) is 
extremely different to the *median of median time gaps* in minutes, then it's likely you need to consider why this is the case for those trips.
- Did you specify tripSplit parameters incorrectly?
- Does the data require further cleaning in some other way?
- What else to consider

> NOTE: you should be aware of what the original pre-programmed sampling interval was. How do you results compare to this interval?

["CONSIDER: What is the best way to provide advice on appropriate time gap selection
for interpolation based on results above vs. comparison with intended sampling interval."]

<br>

## track2KBA: Interpolating data for analysis

If you have gaps between time stamps in your tracking data, you need to fill these gaps for the purpose of the track2KBA protocol. It's likely you will need to do this for many other tracking data analyses.

Broadly speaking, there are two key ways to fill the gaps in your tracking data, a process known as interpolation.

These two ways include:

- Simpler linear interpolation

- More advanced interpolation options that try account for where the animal could have moved (e.g. CRAWL)

> Typically, for flying seabirds, where gaps in tracking data while birds at sea are less likely because birds do not typically dive underwater for durations as long as non-flying seabirds, linear interpolation should serve as a suitable starting point.

> More advanced interpolation methods may be required for diving seabirds, or other diving marine predators.

### Interpolating data: using only at-sea locations

REMINDER: Removing trip start and end points near colony for the interpolation (as completed above), especially if using more advanced methods like CRAWL, can support filtering only points at sea when you estimate birds should be moving, as opposed to trying to deal with sections of trips when the bird is actually stationary on land.

[See appendix for advanced interpolation considerations]

<br>

### Interpolating data: choice of sampling interval

Reminder: The average sampling interval of all data (i.e. the median of median time gaps in minutes) was `r median(SummaryTimeDiff$median_timegap_secs)/60` minutes.

Set your interpolation interval accordingly.

Here we set the interpolation interval in minutes.

[Consider guidance needed]

```{r track2kba-prep-interval-choice}

interp.interval = 30

```

<br>

### Interpolating data: linear interpolation implementation

Prior to implementing linear interpolation using available tools, we save a relevant version of the metadata because the interpolation functions often remove some of the additional metadata which are useful for later steps in the track2kba protocol.

```{r track2kba-prep-linear}

## review data object for analysis
head(data.frame(trips_df),2)

## 
trips_meta <- trips_df %>% 
  dplyr::select(scientific_name,
                common_name,
                site_name,
                colony_name,
                lat_colony,
                lon_colony,
                bird_id = ID,
                trip_id = tripID,
                age,
                sex,
                breed_stage,
                breed_status) %>% 
  group_by(trip_id) %>% 
  slice(1)

## Compare and ensure same number of trips across data
length(unique(trips_df$tripID))
length(unique(trips_meta$trip_id))

```

Now perform the interpolation on each unique trip in your data.

```{r track2kba-prep-linear-2}
## start blank df
trips_interp_df <- data.frame()

for(i in 1:length(unique(trips_df$tripID))){
  
  temp <- trips_df %>% dplyr::filter(tripID == unique(trips_df$tripID)[i])
  
  ## Linear interpolation -----
  ## Apply linear interpolation step to speed filtered only data
  
  ## create ltraj object
  trip_lt <- as.ltraj(xy = bind_cols(x = temp$Longitude, 
                                     y = temp$Latitude),
                      date = temp$DateTime,
                      id = temp$tripID)
  
  ## Linearly interpolate/re-sample tracks according to chose interval (specified in seconds)
  trip_interp <- redisltraj(trip_lt, 
                            interp.interval * 60, 
                            type="time")
  head(trip_interp)
  
  ## convert back into format for track2KBA - dataframe for now
  trip_interp <- ld(trip_interp) %>% 
    dplyr::mutate(Longitude = x,
                  Latitude = y)
  
  ## bind back onto dataframe
  trips_interp_df <- rbind(trips_interp_df, trip_interp)
  
  ## remove temporary items before next loop iteration
  rm(temp,trip_lt)
  
  ## Print loop progress
  print(paste("Trip ", i, " of ", length(unique(trips_df$tripID)), " processed"))

}

## review it worked by checking total number of unique trips and comparing to original
length(unique(trips_df$tripID))
length(unique(trips_interp_df$id))
## compare total number of points
nrow(trips_df)
nrow(trips_interp_df)

```

<br>

Bind metadata back after interpolation. Because we lost the useful metadata after the interpolation step, bind this data back onto the outputted data following interpolation

<br>

```{r track2kba-prep-linear-meta}

## First create columns with same names
trips_interp_df <- trips_interp_df %>% 
  rename(trip_id = id)

## Now bind the metadata back
trips_interp_df <- left_join(trips_interp_df, 
                               trips_meta,
                               by = "trip_id")

## Review data
head(trips_interp_df,2)

```


## Save data

Save relevant data for next steps of track2kba implementation

```{r track2kba-prep-ind-save, include = TRUE}

## create new folder within current working directory where you will save data
  ## first create the name of the species and the file path you need
  ## also use gsub to replace spaces within character strings (words) with a "-"
  species_name <- gsub(" ", "-", trips_interp_df$scientific_name[1]) 
  
  ## print the name for checking
  print(species_name)
  
  ## then create the new folder within current working directory
  path_to_folder <- paste("./data-testing/tracking-data/",
                          species_name,"-track2kba-files",
                          sep="")
  
  ## print the file path name for checking
  print(path_to_folder)
  
  ## Check if folder exists, and if it does not, then make a new folder
    if (!file.exists(path_to_folder)) {
    # If it does not exist, create a new folder
    dir.create(path_to_folder)
    print(paste("Created folder:", path_to_folder))
    } else {
    # do nothing, but let us know the folder exists already
    print(paste("Folder already exists:", path_to_folder))
    }

## save updated file for next steps
write.csv(trips_interp_df, ## cleaned tracking data
     file = paste0(path_to_folder,"/",species_name, "-input-tracks.csv"),
     row.names = F)

write.csv(sumTrips, ## summary of overall trips data
     file = paste0(path_to_folder,"/",species_name, "-input-summary.csv"),
     row.names = F)


```



